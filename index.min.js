angular.module('transformators', []);

angular.module('dependencies', ['ui.router']);

angular.module('app', ['dependencies', 'transformators']);

angular.module('app').config(function($stateProvider, $urlRouterProvider) {
  $urlRouterProvider.otherwise('/');
  return $stateProvider.state('transformatorCounter', {
    url: '/',
    templateUrl: 'views/transformatorCounter/transformatorCounter.html',
    controller: 'TransformatorCounterController'
  }).state('transformatorReview', {
    url: '/review',
    templateUrl: 'views/transformatorCounter/transformatorReview.html',
    controller: 'TransformatorReviewController'
  }).state('linkMatrix', {
    url: '/link_matrix',
    templateUrl: 'views/linkMatrix/linkMatrix.html',
    controller: 'LinkMatrixController'
  });
});

var LinkMatrixController;

LinkMatrixController = function($scope, $state, Schemas, Transformators) {
  $scope.targets = Transformators.getTargets();
  if (!$scope.targets.length) {
    $state.go('transformatorCounter');
  }
  $scope.changeLink = function(from, to, value) {
    return $scope.targets[from].links[to] = $scope.targets[to].links[from] = value;
  };
  return $scope.generateSchemas = function() {
    var container, graph, links;
    links = [];
    _.each($scope.targets, function(target) {
      var availableLinks, link, to;
      availableLinks = [];
      _.each(target.links, function(link, index) {
        if (link === 'unblocked') {
          return availableLinks.push(index);
        }
      });
      if (availableLinks.length) {
        to = _.round(availableLinks.length * _.random(0, 1, true));
        if (to === availableLinks.length) {
          to -= 1;
        }
        to = availableLinks[to];
        link = _.find(links, function(link) {
          return (link.from === target.id && link.to === to) || (link.from === to && link.to === target.id);
        });
        if (!link) {
          return links.push({
            from: target.id,
            to: to
          });
        }
      } else {
        return links.push({
          from: target.id,
          to: target.id
        });
      }
    });
    Schemas.setSchemas({
      nodes: $scope.targets,
      edges: links
    });
    container = document.getElementById('graph');
    return graph = new vis.Network(container, Schemas.getSchemas(), {});
  };
};

angular.module('transformators').controller('LinkMatrixController', LinkMatrixController);

angular.module('transformators').factory('Schemas', function() {
  var getSchemas, schemas, setSchemas;
  schemas = [];
  getSchemas = function() {
    return schemas;
  };
  setSchemas = function(_schemas) {
    return schemas = _schemas;
  };
  return {
    getSchemas: getSchemas,
    setSchemas: setSchemas
  };
});

var TransformatorCounterController;

TransformatorCounterController = function($scope, $state, Transformators, TransformatorSources) {
  var validateTargets;
  $scope.targets = [];
  $scope.addTarget = function() {
    return $scope.targets.push({});
  };
  validateTargets = function() {
    var isError;
    isError = !_.every($scope.targets, function(target) {
      return target.power && target.length;
    });
    if (isError) {
      return 'Есть незаполненные поля';
    }
    isError = Transformators.countTotalPower($scope.targets) > Transformators.maxPower;
    if (isError) {
      return "Мощность потребителей превышает максимальную (" + Transformators.maxPower + " кВА)";
    }
    isError = _.some($scope.targets, function(target) {
      return target.power > Transformators.maxPower / 2;
    });
    if (isError) {
      return "Мощность одного из потребителей превышает максимальную (" + (Transformators.maxPower / 2) + " кВА)";
    }
  };
  $scope.generateLinkMatrix = function() {
    var error;
    error = validateTargets();
    if (error) {
      Materialize.toast(error, 4000);
      return;
    }
    Transformators.setTargets($scope.targets);
    return $state.go('linkMatrix');
  };
  $scope.findTransformators = function() {
    var error;
    error = validateTargets();
    if (error) {
      Materialize.toast(error, 4000);
      return;
    }
    TransformatorSources.findTransformatorSources($scope.targets);
    return $state.go('transformatorReview');
  };
  return $scope.removeTarget = function(index) {
    return $scope.targets.splice(index, 1);
  };
};

angular.module('transformators').controller('TransformatorCounterController', TransformatorCounterController);

var TransformatorReviewController;

TransformatorReviewController = function($scope, $state, TransformatorSources) {
  $scope.sources = TransformatorSources.getTransformatorSources();
  if (!$scope.sources.data) {
    $state.go('transformatorCounter');
  }
  return $scope.findTransformators = function() {
    var transformators;
    transformators = $scope.sources.data;
    return TransformatorSources.findTransformatorSources([].concat(transformators.first.targets, transformators.second.targets));
  };
};

angular.module('transformators').controller('TransformatorReviewController', TransformatorReviewController);

angular.module('transformators').factory('TransformatorSources', function(Transformators) {
  var findTransformatorSources, getTransformatorSources, initTransformatorSources, sources;
  sources = {
    data: null
  };
  initTransformatorSources = function() {
    return sources.data = {
      first: {
        targets: [],
        transformator: null
      },
      second: {
        targets: [],
        transformator: null
      }
    };
  };
  getTransformatorSources = function() {
    return sources;
  };
  findTransformatorSources = function(targets) {
    var isBalanced, isPowered, qTotalPower, results, totalPower, transformators;
    initTransformatorSources();
    totalPower = Transformators.countTotalPower(targets);
    transformators = sources.data;
    results = [];
    while (true) {
      while (true) {
        transformators.first.transformator = Transformators.findTransformator();
        transformators.second.transformator = Transformators.findTransformator();
        isPowered = transformators.first.transformator.power + transformators.second.transformator.power > totalPower;
        qTotalPower = Transformators.countQuarterTotalPower(totalPower);
        isBalanced = transformators.first.transformator.power > qTotalPower && transformators.second.transformator.power > qTotalPower;
        if (isPowered && isBalanced) {
          break;
        }
      }
      _.each(targets, function(target) {
        if (_.random(0, 1, true) < 0.5 && Transformators.countTotalPower(transformators.first.targets) + target.power < transformators.first.transformator.power) {
          return transformators.first.targets.push(target);
        } else {
          return transformators.second.targets.push(target);
        }
      });
      if (transformators.first.transformator.power > Transformators.countTotalPower(transformators.first.targets && transformators.second.transformator.power > Transformators.countTotalPower(transformators.second.targets))) {
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  return {
    getTransformatorSources: getTransformatorSources,
    findTransformatorSources: findTransformatorSources
  };
});

angular.module('transformators').factory('Transformators', function() {
  var countQuarterTotalPower, countTotalPower, findTransformator, getTargets, maxPower, setTargets, targets, transformatorList;
  maxPower = 15000;
  targets = [];
  transformatorList = [
    {
      type: 'TM-10/10',
      power: 10
    }, {
      type: 'TM-20/10',
      power: 20
    }, {
      type: 'TM-25/10',
      power: 25
    }, {
      type: 'TM-30/10',
      power: 30
    }, {
      type: 'TM-40/10',
      power: 40
    }, {
      type: 'TM-50/10',
      power: 50
    }, {
      type: 'TM-63/10',
      power: 63
    }, {
      type: 'TM-100/10',
      power: 100
    }, {
      type: 'TM-160/10',
      power: 160
    }, {
      type: 'TM-180/10',
      power: 180
    }, {
      type: 'TM-250/10',
      power: 250
    }, {
      type: 'TM-320/10',
      power: 320
    }, {
      type: 'TM-400/10',
      power: 400
    }, {
      type: 'TM-560/10',
      power: 560
    }, {
      type: 'TM-630/10',
      power: 630
    }, {
      type: 'TM-750/10',
      power: 750
    }, {
      type: 'TM-1000/10',
      power: 1000
    }, {
      type: 'TM-1600/10',
      power: 1600
    }, {
      type: 'TM-1800/10',
      power: 1800
    }, {
      type: 'TM-3200/10',
      power: 3200
    }, {
      type: 'TM-5600/10',
      power: 5600
    }, {
      type: 'TM-6300/10',
      power: 6300
    }, {
      type: 'TM-7500/10',
      power: 7500
    }
  ];
  getTargets = function() {
    return targets;
  };
  setTargets = function(_targets) {
    _.each(_targets, function(target, index) {
      target.id = index;
      target.links = _.map(_targets, function(target) {
        return 'unblocked';
      });
      return target.links[index] = 'blocked';
    });
    return targets = _targets;
  };
  findTransformator = function() {
    var transformatorIndex;
    transformatorIndex = _.round(transformatorList.length * _.random(0, 1, true));
    if (transformatorIndex === transformatorList.length) {
      transformatorIndex -= 1;
    }
    return transformatorList[transformatorIndex];
  };
  countTotalPower = function(targets) {
    return _.sumBy(targets, 'power');
  };
  countQuarterTotalPower = function(totalPower) {
    return totalPower * 0.25;
  };
  return {
    getTargets: getTargets,
    setTargets: setTargets,
    findTransformator: findTransformator,
    countTotalPower: countTotalPower,
    countQuarterTotalPower: countQuarterTotalPower,
    maxPower: maxPower
  };
});
