angular.module('transformators', []);

angular.module('dependencies', ['ui.router']);

angular.module('app', ['dependencies', 'transformators']);

angular.module('app').config(function($stateProvider, $urlRouterProvider) {
  $urlRouterProvider.otherwise('/');
  return $stateProvider.state('transformatorCounter', {
    url: '/',
    templateUrl: 'views/transformatorCounter/transformatorCounter.html',
    controller: 'TransformatorCounterController'
  }).state('transformatorReview', {
    url: '/review',
    templateUrl: 'views/transformatorCounter/transformatorReview.html',
    controller: 'TransformatorReviewController'
  }).state('linkMatrix', {
    url: '/link_matrix',
    templateUrl: 'views/linkMatrix/linkMatrix.html',
    controller: 'LinkMatrixController'
  });
});

var LinkMatrixController;

LinkMatrixController = function($scope, $state, Schemas, Transformators, Graph) {
  $scope.targets = Transformators.getTargets();
  $scope.source = Transformators.getSource();
  if (!$scope.targets.length) {
    $state.go('transformatorCounter');
  }
  $scope.changeLink = function(from, to, value) {
    return $scope.targets[from].links[to] = $scope.targets[to].links[from] = value;
  };
  $scope.changeLinkLength = function(from, to, value) {
    return $scope.targets[from].linksLength[to] = $scope.targets[to].linksLength[from] = value;
  };
  return $scope.generateSchemas = function() {
    var container, data, graph, maxX, maxY, s;
    while (true) {
      graph = Graph.initGraph($scope.targets.length);
      _.each($scope.targets, function(target) {
        var availableLinks, link, to;
        availableLinks = [];
        _.each(target.links, function(link, index) {
          if (link === 'unblocked') {
            return availableLinks.push(index);
          }
        });
        if (availableLinks.length) {
          to = _.round(availableLinks.length * _.random(0, 1, true));
          if (to === availableLinks.length) {
            to -= 1;
          }
          to = availableLinks[to];
          link = _.find(Graph.getGraph().links, function(link) {
            return (link.from === target.id && link.to === to) || (link.from === to && link.to === target.id);
          });
          if (!link) {
            return Graph.addLink(target.id, to);
          }
        }
      });
      if (!Graph.isCyclic()) {
        break;
      }
    }
    container = document.getElementById('graph');
    Schemas.setSchemas({
      nodes: $scope.targets,
      edges: Graph.getGraph().links
    });
    graph = new vis.Network(container, Schemas.getSchemas(), {});
    data = {
      nodes: _.map($scope.targets, function(target) {
        return {
          id: "n" + target.id,
          label: target.label,
          x: target.x,
          y: target.y,
          size: 3
        };
      }),
      edges: _.map(Graph.getGraph().links, function(link, i) {
        return {
          id: "e" + i,
          source: "n" + link.from,
          target: "n" + link.to
        };
      })
    };
    $('#graph2').remove();
    $('#graph-container').html('<div id="graph2" style="height:400px"></div>');
    s = new sigma('graph2');
    maxX = _.max(_.map($scope.targets, 'x'));
    if (maxX < $scope.source.x) {
      maxX = $scope.source.x;
    }
    maxY = _.max(_.map($scope.targets, 'y'));
    if (maxY < $scope.source.y) {
      maxY = $scope.source.y;
    }
    _.each($scope.targets, function(target) {
      return s.graph.addNode({
        id: "n" + target.id,
        label: target.label,
        x: target.x,
        y: maxY - target.y,
        size: 3
      });
    });
    _.each(Graph.getGraph().links, function(link, i) {
      return s.graph.addEdge({
        id: "e" + i,
        source: "n" + link.from,
        target: "n" + link.to
      });
    });
    s.graph.addNode({
      id: "n" + ($scope.targets.length + 1),
      label: $scope.source.label,
      x: $scope.source.x,
      y: maxY - $scope.source.y,
      size: 5,
      color: 'yellow'
    });
    _.each($scope.targets, function(target, i) {
      return s.graph.addEdge({
        id: "e" + (i + $scope.targets.length),
        source: "n" + target.id,
        target: "n" + ($scope.targets.length + 1),
        color: 'yellow'
      });
    });
    s.settings({
      defaultNodeColor: '#FF6384',
      edgeColor: '#FF6384'
    });
    return s.refresh();
  };
};

angular.module('transformators').controller('LinkMatrixController', LinkMatrixController);

angular.module('transformators').factory('Schemas', function() {
  var getSchemas, schemas, setSchemas;
  schemas = [];
  getSchemas = function() {
    return schemas;
  };
  setSchemas = function(_schemas) {
    return schemas = _schemas;
  };
  return {
    getSchemas: getSchemas,
    setSchemas: setSchemas
  };
}).factory('Graph', function() {
  var _isCyclicUtil, addLink, getGraph, graph, initGraph, isCyclic;
  graph = {
    v: null,
    links: [],
    adg: []
  };
  getGraph = function() {
    return graph;
  };
  initGraph = function(v) {
    var adg, i, j, len, ref;
    adg = [];
    ref = _.range(v);
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      adg.push([]);
    }
    return _.extend(graph, {
      v: v,
      links: [],
      adg: adg
    });
  };
  addLink = function(v, w) {
    graph.links.push({
      from: v,
      to: w
    });
    graph.adg[v].push(w);
    return graph.adg[w].push(v);
  };
  _isCyclicUtil = function(v, visited, parent) {
    var i, j, len, ref;
    visited[v] = true;
    ref = graph.adg[v];
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      if (!visited[i]) {
        if (_isCyclicUtil(i, visited, v)) {
          return true;
        }
      } else if (i !== parent) {
        return true;
      }
    }
    return false;
  };
  isCyclic = function() {
    var i, j, k, len, len1, ref, ref1, u, visited;
    visited = [];
    ref = _.range(graph.v);
    for (j = 0, len = ref.length; j < len; j++) {
      i = ref[j];
      visited[i] = false;
    }
    ref1 = _.range(graph.v);
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      u = ref1[k];
      if (!visited[u]) {
        if (_isCyclicUtil(u, visited, -1)) {
          return true;
        }
      }
    }
    return false;
  };
  return {
    getGraph: getGraph,
    initGraph: initGraph,
    addLink: addLink,
    isCyclic: isCyclic
  };
});

var TransformatorCounterController;

TransformatorCounterController = function($scope, $state, Transformators, TransformatorSources) {
  var validateTargets;
  $scope.targets = Transformators.getTargets();
  $scope.source = Transformators.getSource();
  $scope.addTarget = function() {
    return $scope.targets.push({
      label: "ТП" + ($scope.targets.length + 1),
      r: 15
    });
  };
  validateTargets = function() {
    var isError;
    isError = !_.every($scope.targets, function(target) {
      var t;
      t = target;
      return t.power && t.x && t.y && t.transformatorsCount && t.cos && t.time;
    });
    isError = isError || !($scope.source.x && $scope.source.y);
    if (isError) {
      return 'Есть незаполненные поля';
    }
    isError = Transformators.countTotalPower($scope.targets) > Transformators.maxPower;
    if (isError) {
      return "Мощность потребителей превышает максимальную (" + Transformators.maxPower + " кВА)";
    }
    isError = _.some($scope.targets, function(target) {
      return target.power > Transformators.maxPower / 2;
    });
    if (isError) {
      return "Мощность одного из потребителей превышает максимальную (" + (Transformators.maxPower / 2) + " кВА)";
    }
  };
  $scope.generateLinkMatrix = function() {
    var error;
    if (error = validateTargets()) {
      Materialize.toast(error, 4000);
      return;
    }
    Transformators.setTargets($scope.targets);
    return $state.go('linkMatrix');
  };
  $scope.findTransformators = function() {
    var error;
    error = validateTargets();
    if (error) {
      Materialize.toast(error, 4000);
      return;
    }
    TransformatorSources.findTransformatorSources($scope.targets);
    return $state.go('transformatorReview');
  };
  $scope.removeTarget = function(index) {
    return $scope.targets.splice(index, 1);
  };
  return $scope.draw = function() {
    var bubbleCart, container, error;
    if (error = validateTargets()) {
      Materialize.toast(error, 4000);
      return;
    }
    container = document.getElementById('data-set');
    return bubbleCart = new Chart(container, {
      type: 'bubble',
      data: {
        datasets: [
          {
            label: 'ИП',
            data: [$scope.source],
            backgroundColor: 'yellow',
            hoverBackgroundColor: 'yellow'
          }, {
            label: 'ТП',
            data: $scope.targets,
            backgroundColor: '#FF6384',
            hoverBackgroundColor: '#FF6384'
          }
        ]
      },
      options: {
        title: {
          display: true,
          text: 'Карта-схема расположения потребителей'
        },
        tooltips: {
          callbacks: {
            title: function(item, datasets) {
              item = item[0];
              return datasets.datasets[item.datasetIndex].data[item.index].label;
            },
            label: function(tooltipItem, data) {
              return "(x: " + tooltipItem.xLabel + "; y: " + tooltipItem.yLabel + ")";
            }
          }
        }
      }
    });
  };
};

angular.module('transformators').controller('TransformatorCounterController', TransformatorCounterController);

var TransformatorReviewController;

TransformatorReviewController = function($scope, $state, TransformatorSources) {
  $scope.sources = TransformatorSources.getTransformatorSources();
  if (!$scope.sources.data) {
    $state.go('transformatorCounter');
  }
  return $scope.findTransformators = function() {
    var transformators;
    transformators = $scope.sources.data;
    return TransformatorSources.findTransformatorSources([].concat(transformators.first.targets, transformators.second.targets));
  };
};

angular.module('transformators').controller('TransformatorReviewController', TransformatorReviewController);

angular.module('transformators').factory('TransformatorSources', function(Transformators) {
  var findTransformatorSources, getTransformatorSources, initTransformatorSources, sources;
  sources = {
    data: null
  };
  initTransformatorSources = function() {
    return sources.data = {
      first: {
        targets: [],
        transformator: null
      },
      second: {
        targets: [],
        transformator: null
      }
    };
  };
  getTransformatorSources = function() {
    return sources;
  };
  findTransformatorSources = function(targets) {
    var isBalanced, isPowered, qTotalPower, results, totalPower, transformators;
    initTransformatorSources();
    totalPower = Transformators.countTotalPower(targets);
    transformators = sources.data;
    results = [];
    while (true) {
      while (true) {
        transformators.first.transformator = Transformators.findTransformator();
        transformators.second.transformator = Transformators.findTransformator();
        isPowered = transformators.first.transformator.power + transformators.second.transformator.power > totalPower;
        qTotalPower = Transformators.countQuarterTotalPower(totalPower);
        isBalanced = transformators.first.transformator.power > qTotalPower && transformators.second.transformator.power > qTotalPower;
        if (isPowered && isBalanced) {
          break;
        }
      }
      _.each(targets, function(target) {
        if (_.random(0, 1, true) < 0.5 && Transformators.countTotalPower(transformators.first.targets) + target.power < transformators.first.transformator.power) {
          return transformators.first.targets.push(target);
        } else {
          return transformators.second.targets.push(target);
        }
      });
      if (transformators.first.transformator.power > Transformators.countTotalPower(transformators.first.targets && transformators.second.transformator.power > Transformators.countTotalPower(transformators.second.targets))) {
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
  return {
    getTransformatorSources: getTransformatorSources,
    findTransformatorSources: findTransformatorSources
  };
});

angular.module('transformators').factory('Transformators', function() {
  var countQuarterTotalPower, countTotalPower, findTransformator, getSource, getTargets, maxPower, setTargets, source, targets, transformatorList;
  maxPower = 15000;
  targets = [];
  source = {
    label: 'Источник Питания',
    x: null,
    y: null,
    r: 30
  };
  transformatorList = [
    {
      type: 'TM-10/10',
      power: 10
    }, {
      type: 'TM-20/10',
      power: 20
    }, {
      type: 'TM-25/10',
      power: 25
    }, {
      type: 'TM-30/10',
      power: 30
    }, {
      type: 'TM-40/10',
      power: 40
    }, {
      type: 'TM-50/10',
      power: 50
    }, {
      type: 'TM-63/10',
      power: 63
    }, {
      type: 'TM-100/10',
      power: 100
    }, {
      type: 'TM-160/10',
      power: 160
    }, {
      type: 'TM-180/10',
      power: 180
    }, {
      type: 'TM-250/10',
      power: 250
    }, {
      type: 'TM-320/10',
      power: 320
    }, {
      type: 'TM-400/10',
      power: 400
    }, {
      type: 'TM-560/10',
      power: 560
    }, {
      type: 'TM-630/10',
      power: 630
    }, {
      type: 'TM-750/10',
      power: 750
    }, {
      type: 'TM-1000/10',
      power: 1000
    }, {
      type: 'TM-1600/10',
      power: 1600
    }, {
      type: 'TM-1800/10',
      power: 1800
    }, {
      type: 'TM-3200/10',
      power: 3200
    }, {
      type: 'TM-5600/10',
      power: 5600
    }, {
      type: 'TM-6300/10',
      power: 6300
    }, {
      type: 'TM-7500/10',
      power: 7500
    }
  ];
  getTargets = function() {
    return targets;
  };
  getSource = function() {
    return source;
  };
  setTargets = function(_targets) {
    _.each(_targets, function(target, index) {
      target.id = index;
      target.links = _.map(_targets, function() {
        return 'unblocked';
      });
      target.linksLength = [];
      return target.links[index] = 'blocked';
    });
    _.each(_targets, function(target) {
      return _.each(_targets, function(_target) {
        return target.linksLength[_target.id] = Math.sqrt(Math.pow(_target.x - target.x, 2) + Math.pow(_target.y - target.y, 2));
      });
    });
    return targets = _targets;
  };
  findTransformator = function() {
    var transformatorIndex;
    transformatorIndex = _.round(transformatorList.length * _.random(0, 1, true));
    if (transformatorIndex === transformatorList.length) {
      transformatorIndex -= 1;
    }
    return transformatorList[transformatorIndex];
  };
  countTotalPower = function(targets) {
    return _.sumBy(targets, 'power');
  };
  countQuarterTotalPower = function(totalPower) {
    return totalPower * 0.25;
  };
  return {
    getTargets: getTargets,
    setTargets: setTargets,
    getSource: getSource,
    findTransformator: findTransformator,
    countTotalPower: countTotalPower,
    countQuarterTotalPower: countQuarterTotalPower,
    maxPower: maxPower
  };
});
